[{"categories":["arduino","feedback control theory"],"content":"Introduction The inverted pendulum is one of the most popular demonstrations in system control, has been studied since the 19601 and prime example at unis and other reseach institutes. However the inverted pendulum, which is nothing more than a pendulum that has the center of mass above the pivot point, yet has not particular use case. To change this once in for all, I build a inverted pendulum lamp, which can be used as a normal stylsh desk lanmp. (The main incentive however wasn‚Äôt so heroic. Honestly! It sounded just like a nice project idea!) Note\r\rThis blog post will give you a step by step recreation guide and highlights the the design choices I made as well as introduce you to the implementation of the LQR Control Algorithm I used to balance the Lamp. I will also mention the resources that i used to speed up the programming part at the the end of the post!\r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:1:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Building ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Components List of used parts\r\r üìü Arduino UNO ‚ö° L298N motor driver ‚öôÔ∏è Geared DC-motor 39.6 mm, 15:1, 12 V DC üîå Capsule Slip Ring AC 240V üìè Wdd35d4-5k Contious Angle Sensor üîå 1 Cannel Relay 5V/230V üìè Potentiometer 50k (linear) üí° E27 Fassung \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:1","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Mechanical Setup To accomplish this symbiosis between this still highly complex balancing problem and the potential usage as a design element, I first had to desing a balancing cart üöó with a pivoting E27 socket for the lamp üí°. This brings the extra challenge of feeding a, in this case 230V, cable throw various mountings and controlling it using a ordinary relay. Design-choices\r\r","date":"2020-08-31","objectID":"/inverted_pendolum/:2:2","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"‚öôÔ∏è DV-Motor (first axel) the L298N Motor Driver Module works up to 12V , without removing the jumper wire, therefore a 12V DV-Motor is a good choice for the setup a DC-Motor with 300-440 RPM or with a 15:1 gear ratio and a high enought torque, 10Ncm in my case (but that much might not be necessary) was sufficient for my setup ‚ùó be carefull with the maximum current! The allowed Amps for the L298N Motor Driver Module is 2A (more information here) ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:3","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìè Contious Angle Sensor (second axel) is used to monitor the position of the cart üöó relative to its starting position the angle sensor works like a normal potentiometer but allows for more that 360¬∞ turning angle. not the most reliable solution as it produced high noise in the zero orientation =\u003e Quick-fix: use a capacitor as a low-pass filter between the ground and output voltage. ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:4","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìü Arduino the L298 has a 5V regulator and can be used as the power supply (see connection diagram) ‚ùó dont mount any high current consumer like the lamp üí° or the motor ‚öô to the 5V output of the board it is not made for such high currents. ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:5","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìè Potentiometer 50k (linear) used to detect the angel of the pendulum additionally used as a mount for the pendulum ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:6","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üîå Capsule Slip Ring AC 240V the lamp üí° is powerd by a isolated electric circuit with 240V AC the slip ring feeds the power thought the rotational pivot point also used as mount for the pendelum ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:7","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üîå Relay isolates the 12V DC and the 240V AC is triggerd by the arduino \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:8","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Connecting Motor Driver Board ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:9","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Connecting Potentiometer ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:10","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Integration of Relay2 Simple introduction to connect the relay to the arduino ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:11","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Control Algorithm In the following section I will give a brief introduction to the theory of the LQR Controller and provide you with my recommended resources which help you determine the coefficients of the feedback regulator! ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Mathematical representation The simplified system consists of a inverted pendulum which is connected to a motorized card. Without further inspection we can recognize that we are looking at a unstable system. If the cart is not moved it is nearly impossible to balance the pendulum in the upright position. The objective is it now to design a feedback controller which accelerates the carte enough so that the angle $ \\phi $ of the pendulum is close to 180¬∞. However we first have to define the nonlinear model: List of Variables\r\r M mass of the cart m mass of pendulum b coefficient of friction for cart l length to pendulum center of mass I mass moment of inertia of the pendulum F force applied to the cart x cart position coordinate $\\theta$ pendulum angle from vertical (down) u (input) here equivalent to the Force F \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:1","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"LQR Controller ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:2","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Determine grains The script to determine the gains for the LQR Controller can be found here! ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:3","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"DC-Motor system identification The LQR Controller takes as a input the Force F of the DC-Motor. Therefore the next step is to find the undelying DC-Motor model and estimate the corresponding system parameters. Then the arduino is able to change the speed of the engine using the PWM signal. We can model a standard DC-Motor using the following equation: $$ \\frac{d w}{d t}\\left(J+m r^{2}\\right)+w\\left(B+\\frac{k^{2}}{R}\\right)=\\frac{k U}{R} $$ Simplifying this further: To determine the parameters a,b,c we can record several velocity curves with different input voltages. Using the following plot and theses scripts [dc_motor_lqr_control.py,estimate_params.py] we can now find the exact model parameters! Credits to zjor for creating the scripts3 ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:4","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Conclustion ","date":"2020-08-31","objectID":"/inverted_pendolum/:4:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Code The code is based on a existing arduino project3 #define A 9 #define B 1.0 #define C 2.1 #define Kth 61.20847945 #define Kw 10.42165907 #define Kx 16.2303454 #define Kv 13.43669139 #define Ki 0 #define PI 3.1415926535897932384626433832795 //define pins int speed = 9; int front = 6; int back = 7; int lamp = 2; //define constans float wheelCirc = 141.37; float THETA_THRESHOLD = PI / 8; unsigned long now = 0L; unsigned long lastTimeMicros = 0L; //init States float x=0; float d_x; float phi; float d_phi; float phi_sum=0; //usefull variables float pos_last1; float pos_last2; float pos_last3; float pos_last4; float last_phi; float control, u, dt , v_soll; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); pinMode(speed, OUTPUT); pinMode(front, OUTPUT); pinMode(back, OUTPUT); pinMode(lamp, OUTPUT); digitalWrite(lamp,HIGH); digitalWrite(front, LOW); digitalWrite(back, LOW); pos_last1= mapf(analogRead(A1),0,1023,0,wheelCirc)/1000; pos_last2=pos_last1; pos_last3=pos_last1; pos_last4=pos_last1; last_phi= mapf(analogRead(A0)-512+4 , -512, 512, -PI ,PI ); lastTimeMicros = 0L; //Debugging //Serial.print(\"x\");Serial.print(\"\\t\"); //Serial.print(\"dx\");Serial.println(\"\\t\"); //Serial.print(\"Kv*d_x\");Serial.print(\"\\t\"); //Serial.print(\"Kth*phi\");Serial.print(\"\\t\"); //Serial.print(\"Kw*d_phi\");Serial.print(\"\\t\"); //Serial.print(\"control\");Serial.print(\"\\t\"); //Serial.print(\"u\");Serial.println(\"\\t\"); } float mapf(float x, float in_min, float in_max, float out_min, float out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; } void driveMotor(float pwm_out){ analogWrite(speed, fabs(pwm_out)); if (pwm_out \u003e 0) { digitalWrite(front, HIGH); digitalWrite(back, LOW); }else if (pwm_out \u003c 0) { digitalWrite(front, LOW); digitalWrite(back, HIGH); }else{ digitalWrite(front, LOW); digitalWrite(back, LOW); } } boolean isControllable(float phi) { return fabs(phi) \u003c THETA_THRESHOLD; } float saturate(float v, float maxValue) { if (fabs(v) \u003e maxValue) { return (v \u003e 0) ? maxValue : -maxValue; } else { return v; } } float derivative(float x_new, float x_old, float dt){ float d_temp= x_new - x_old; float d_pos = 0; if (fabs(d_temp) \u003c fabs(d_temp+wheelCirc/1000) and (fabs(d_temp) \u003c fabs(d_temp-wheelCirc/1000))){ d_pos= d_temp; }else if (fabs(d_temp+wheelCirc/1000) \u003c fabs(d_temp-wheelCirc/1000)){ d_pos= (d_temp+wheelCirc/1000); }else { d_pos= (d_temp-wheelCirc/1000); } if (fabs(d_pos/dt)\u003e1.1){ d_pos= -d_x*dt; } return - d_pos/dt; } void updateStates(float dt){ //read sensor input (Angle of wheel) float sensor_x = analogRead(A1); float pos_new =mapf(sensor_x,0,1023,0,wheelCirc)/1000; //smoothing the signal input float pos_avg= (pos_last1+pos_last2+pos_last3+pos_last4)/4; float d_x_2 = derivative(pos_new, pos_last2,2*dt); float d_x_3 = derivative(pos_new, pos_last3,3*dt); d_x = (d_x_2+d_x_3)/2; //update state variables x = x + dt*d_x; pos_last4=pos_last3; pos_last3=pos_last2; pos_last2=pos_last1; pos_last1=pos_new; //read sensor phi float sensor_phi = analogRead(A0) - 512; phi = mapf(sensor_phi+8 , -512, 512, -PI, PI ); // map sensor input to correct mean an variance d_phi=(phi-last_phi)/dt; last_phi= phi; phi_sum=phi_sum+dt*phi; if (isControllable(phi)){ phi_sum=0; } //Debugging //Serial.print(sensor_x, 4);Serial.print(\"\\t\"); //Serial.print(sensor_x, 4);Serial.print(\"\\t\"); //Serial.print(pos_new, 4);Serial.print(\"\\t\"); //Serial.print(d_x*1000, 4);Serial.println(\"\\t\"); //Serial.print(d_x_2*1000, 4);Serial.print(\"\\t\"); //Serial.print(d_x_3*1000, 4);Serial.println(\"\\t\"); //Serial.print(d_x_4*1000, 4);Serial.println(\"\\t\"); //Serial.print(phi, 4);Serial.print(\"\\t\"); //Serial.print(d_phi, 4);Serial.print(\"\\t\"); } // the loop routine runs over and over again forever: void loop() { now = micros(); dt = (1.0*(now - lastTimeMicros))/ 1000000; updateStates(dt); if (isControllable(phi)) { digitalWrite(lamp, LOW); control = (Kx * x + Kv * d_x + Kth * phi +","date":"2020-08-31","objectID":"/inverted_pendolum/:5:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Links http://web.mit.edu/klund/www/papers/Roberge1960.pdf ‚Ü©Ô∏é https://diyi0t.com/relay-tutorial-for-arduino-and-esp8266/ ‚Ü©Ô∏é https://create.arduino.cc/projecthub/zjor/inverted-pendulum-on-a-cart-199d6f ‚Ü©Ô∏é ","date":"2020-08-31","objectID":"/inverted_pendolum/:6:0","tags":["electronics","dc motor","L298n","lamp"],"title":"InverterdPendelum","uri":"/inverted_pendolum/"}]